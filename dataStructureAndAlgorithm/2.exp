<(3前)データ構造とアルゴリズム2,t>コンピュータで(ア)を解釈するには、(イ)、即ち(ウ)を知る必要がある。{{br}}そして(エ)を言語という。{{br}}また(オ)を「生成」という。


(ア):文字列{{br}}(イ):それがどのようなルールで作られているか{{br}}(ウ):文法{{br}}(エ):ルールに適合する文字列全ての集合{{br}}ルールから適合する文字列を導くこと
特定の文法を記号Gで表すとき、その文法で生成される言語の集合を(ア)とかくことがある。{{br}}そして(イ)をアルファベットといい、Σで表す。{{br}}(ウ)をΣ＊で表す。{{br}}空列はεで表す。


(ア):L(G){{br}}(イ):記号の全体集合{{br}}(ウ):Σから作られる記号列全体の集合
Σ＝｛0,1｝のとき、Σ＊を表せ


Σ＊＝｛ε,0,1,00,01,10,11,000,...｝
Σ＝｛0,1｝{{br}}G＝(1で終わらないもの){{br}}のとき、L(G)を表せ


L(G)＝｛ε,0,00,10,000,010,100,110,...｝
正規表現の定義を言え


下記のいずれかに該当するもの。{{br}}ε{{br}}アルファベット1文字{{br}}RとSが正規表現のとき、R | S,RS, ｛R｝
正規表現において、R｜Sとは何か


RまたはS
正規表現において、RSとは何か


Rの次の文字がSである文字列(独自解釈)
正規表現において、｛R｝とは何か


Rの0回以上の繰り返し
正規表現は一つの(ア)になりうるので、正規表現で(イ)を定義することができる。


(ア):文法{{br}}(イ):言語
アルファベットを数字とする。{{br}}L(G)＝自然数の時、Gを言え。{{br}}解説もせよ。


G＝［123456789］｛［0123456789］｝{{br}}［ab］とはa|bを示す。{{br}}要は、一番最初に0を許さなければ、後は自由に0〜9を並べる。
「メモリが有限個」と「正規表現」を使って、真となる命題を作れ


メモリが有限個しか使えないコンピュータが計算できる言語 ならば 正規表現だけ
Javaで正規表現を表す例を示す。{{br}}穴埋めせよ。{{br}}(ア)は任意の一文字を表す正規表現である{{br}}正規表現では文字列の(イ)は(ウ)、(エ)は(オ)で表現する。{{br}}(カ)以外は正規表現{{br}}［と］に囲まれる文字の列は(キ)を表す。A-Zと表現すればAからZまでのすべての文字を表す。{{br}}［＾と]に囲まれる文字の列は(ク)を表す。{{br}}Rが一文字を表す正規表現の時、(ケ)はRが0回または1回を表す。(コ)はRの0回以上の繰り返し、(サ)は1回以上の繰り返しを表す。Rが複数文字を表す場合は、Rをかっこで囲む


(ア):「.」{{br}}(イ):始まり{{br}}(ウ):「＾」{{br}}(エ):終わり{{br}}(オ):「＄」{{br}}(カ):特殊文字{{br}}(キ):それらの文字の内どれか一文字{{br}}(ク):それらの文字のどれにも含まれない文字一文字{{br}}(ケ):R？{{br}}(コ):R＊{{br}}(サ):R＋
Javaで正規表現を表すとき、「￥d」とすると、数字1桁を表す。{{br}}これを本来の正規表現で表せ


［0-9］
Javaで正規表現を表すとき、「￥D」とすると、数字以外1文字を表す。{{br}}これを本来の正規表現で表せ


［＾0-9］
Javaで正規表現を表すとき、「.」を本来の正規表現で表す例を挙げよ(独自解釈)


［0-9］|［＾0-9］{{br}}数字または数字以外の1文字
先頭がaで始まる文字列の正規表現を表せ


＾a.＊＄
aを含む文字列の正規表現を表せ


＾.＊a．＊$
英字で始まり、残りは英字と数字だけの文字列を正規表現で表せ


＾(［a-z］|［A-Z］)(［a-z］|［A-Z］|［0-9］)＊＄
次の正規表現が表す文字列を説明せよ。{{br}}＜［＾＞］＋＞


「＜」が1回以上登場する。{{br}}「＜」に対し、「＞」が後ろにある
オートマトンとは何か。定義と図の例を示せ。


開始ノードが1つ指定される{{br}}終了ノードが1つ以上指定される{{br}}ノード間の各矢印に、文字が1つ以上割り振られる。{{br}} {画像=21.png}
文字列の用意する。{{br}}オートマトンを(ア)ことを考える。{{br}}(ア)ことをして、その文字列が生成されうる場合、文字列は(イ)されたという。そうでなければ拒否されたという。{{br}}(イ)される文字列の集合を(ウ)という。


(ア):開始ノードから一文字ずつたどって終了ノードにたどり着く{{br}}(イ):受理{{br}}(ウ):言語
次のオートマトンが受理する文字列の正規表現を示せ{{br}} {画像=21.png}


(＾A+B)｜(C(B(C|(＾A+B)))＊){{br}}(独自解釈)
オートマトンについて、各ノードから出る文字が(ア)とき、決定性オートマトンという。{{br}}(ア)でない場合は非決定性オートマトンという。{{br}}(イ)決定性オートマトンは状態遷移図そのものである。{{br}}(ウ)決定性オートマトンの処理する言語は、正規表現の言語に一致する


(ア):すべて異なり、また空文字でない{{br}}(イ):ε(つまり、決定性オートマトン){{br}}(ウ):非
正規表現の文法から非決定性オートマトンを作ることができることを説明する。{{br}}まず文字Aを受理するオートマトンは(ア)のように表し、{{br}}正規表現Rで表される文字列を受理するオートマトンは(イ)のように表すとする。{{br}}この時、R｜Sは(ウ)のように、RSは(エ)のように、｛R｝は(オ)のように表される。


(ア):{画像=22.png} {{br}}(イ):{画像=23.png} {{br}}(ウ):{画像=24.png} {{br}}(エ):{画像=25.png} {{br}}(オ):{画像=26.png}
正規表現(ab|bc)の、簡単化されたオートマトンを示せ。


まず普通に(ab|bc)のオートマトンを示す。{{br}} {画像=27.png} {{br}}次に、空文字εを省き、まとめられるところはまとめる。「,」すら用いてよい。{{br}} {画像=28.png}
(ab|bc)は{{br}} {画像=28.png} {{br}}で示される。{{br}}では(ab|bc)＊はどう表されるか。


まず{{br}} {画像=29.png} {{br}}である。εの省略はいわずもがな、よく見てみると、b,cのあと、「終了」ノードと「aを送る」ノードとに分岐している。{{br}}これらのノードを1つにまとめてしまう発想を許せば、次のとおり。{{br}} {画像=30.png}
a＊を受理するオートマトンを示せ。またa＋を受理するオートマトンを示せ


a＊{{br}} {画像=31.png} {{br}}{{br}}a＋{{br}} {画像=32.png}
.＊(a|b)?[01]＊を受理するオートマトンを示せ


{画像=33.png} {{br}}簡単化すると{{br}} {画像=34.png}</>
<pass==pass>