# computerArchitecture(コンピュータアーキテクチャ)  

## 第3回

### 整数の計算

(オーバフローフラグの設計は省略)  

4bit加減算器で、符号なしで12-10を計算しよう。  
bit表示すると、ア: <!-- hole 1100-1010 --> = イ: <!-- hole 0010 -->となる。  
キャリーフラグCAは ウ: <!-- hole 立たない(0) --> し、 オーバフローフラグOVは エ: <!-- hole 0 -->  
この演算は正しい。  
4bit加減算器で、符号なしで12+13を計算しよう。  
bit表示すると、オ: <!-- hole 1100+1101 --> = カ: <!-- hole 1001 -->となる。  
CA= キ: <!-- hole 1 --> 、 OV= ク: <!-- hole 0 -->  
この演算は誤り。  
4bit加減算器で、符号付きで-4+(-3)を計算しよう。  
bit表示すると、オ = カとなる。  
CA= キ 、 OV= ク  
この演算は正しい。  
(他にも宿題があるので、それをすべてまとめる。非公開情報)


(どんな計算の時、どのフラグによって、計算が正しいと判断できるかまとめるべき)  

### 小数点の計算

#### 固有小数点数

例えば 10.75は ア: <!-- hole 1010.1100 --> と表される。  
.1100=.1+.01+.000+.0000= イ: <!-- hole 0.5*1+0.25*1+0.125*0+0.0625*0 -->  
ということである。  

整数の場合でも同じことが言えるのであるが、  
2進数 `1xxx` が 符号なしでnを意味するとき、符号ありでは ウ: <!-- hole -(10000-n) --> を意味する。  
2進数 `0xxx` が 符号なしでnを意味するとき、符号ありでは エ: <!-- hole n --> を意味する。  

(演習問題もやる。非公開情報)  

#### 浮動小数点  

##### 浮動小数点とは

固有小数点で表現すると、すぐ溢れてしまい、特に科学技術計算などで困る。  
例えば光の秒速mは0.3×10^9であるが、これを表すのに何bit必要だろうか。  
概算したいときは、 ア: <!-- hole 2^10=1024≒1000=10^3 --> という関係を使う。  
0.3×10^9は300×10^6であるが、(精度無視)  
これはイ: <!-- hole 512×10^3×10^3 --> より小さく、しかし近い。  
イ≒ウ: <!-- hole 2^9×2^10×2^10=2^29 --> である。  
したがって、エ: <!-- hole 29 --> bit必要であるとわかるのである。  
これではもったいないので、「浮動小数点」という、別の表現方法が開発され、IEEEで標準化されている。  
IEEE Standard 754では 単精度32bitの他、倍精度64bitや半精度16bitを用意している。  
これらのbitを符号ビット、オ: <!-- hole 指数ビット --> 、 カ: <!-- hole 仮数ビット --> に分けて使う。  
符号ビットは当然1だけ。なので、オのビット数さえわかれば、単精度なら32-1-(オのビット数)がカのビット数となり、カのビット数は計算で求められる。  
単精度のオ･･･キ: <!-- hole 8 --> bit  
倍精度のオ･･･ク: <!-- hole 11 --> bit  
半精度のオ･･･ケ: <!-- hole 5 --> bit  
である。  

##### 浮動小数点の作り方  

10進数228 を単精度で表現しよう。  
まず2進数に変換すると、11100100である。  
そして、ア: <!-- hole (仮数の)先頭は絶対1(何bitで表すとかではなくて) --> なんだから、先頭の1を省略してしまう。  
すると、イ: <!-- hole 1100100 --> となる。  

これを仮数部23bitにする。足りない分は、ウ: <!-- hole 右に0を補う -->  
エ: <!-- hole 110_0100_0000_0000_0000_0000 --> となる。  

指数部は8bitであり、これが表現できる整数は-127～128  

ここで、10進数228は、1.1100100×2^7で表されるから、  
指数部は7=0000_0111となりそうだが、なぜか オ: <!-- hole (2^(指数部bit数))-1=127 -->だけ足すというルールがあって、  
カ: <!-- hole 127+7=134 --> =0100_0011を指数部とする。  


##### 浮動小数点から数値の求め方

(32ページもまとめる)  

##### IEEE 754 浮動小数点における特殊表現

そもそも浮動小数点では、「仮数部の先頭は必ず1」をフルに応用してしまったため、 ア: <!-- hole 0を表現することができなくなってしまった --> 。  
これをごまかすために、「例外的な表現」を用意した。  
これを特殊表現という。  
ついでに±∞や「非正規化数」だったり、NaNもここで決めている。  
それを表にまとめたのが [イ](img/ieee754_1.png) である。  
非正規化数とは、 ウ: <!-- hole 「仮数部の先頭は必ず1」を使わないで表した数 --> のことである。  
正規化数や非正規化数は、 [エ](img/ieee754_2.png) で表される。  
Sは符号(ビット)、Mは仮数、Mは指数ビット  
非正規化数の2^-126は、単に オ: <!-- hole E=1 --> とみるのではだめなのだろうか。  

##### IEEE 754 浮動小数点の範囲

単精度:最大値は、ア(bit表記せよ): <!-- hole 0_11111110_11111111111111111111111 --> ＝イ(数値でいえ): <!-- hole 1.11...1×2^127 --> であるから、  
およそ2×2^127である。  
＝(1+1)(2^10)^12 × 2^7  
≒2×10^36×100

## 第4回

(レポートの内容と同じものをまずやった。以下は、その他のものの復習である)  

### 二つのエンディアン

バイトのメモリに保存される順番には2通りある。  
例えばshort int 0xc350と0x1234を配置するとき、   
[ア](img/endian.png)  
のようになる。  

ビッグエンディアンが、「並び方そのまま」で、リトルエンディアンが「並び方が捻くれてる」ので、「小(リトル)心者ほど捻くれる」と覚えればいい。  

### Von Neumann architecture(ノイマン型)

コンピュータにおいて、プログラムの保管場所や処理される方式には種類がある。  
大きくノイマン型と非ノイマン型に大別されるが、ここでは前者のみを扱う。  

プログラムをア: <!-- hole 内部メモリ --> に記憶していることをイ: <!-- hole プログラム可変内蔵方式 --> という。  
これのメリットは、ウ: <!-- hole 可搬性が高く、プログラムの入力や変更が簡単になること --> である。  
アに記憶したプログラムをエ: <!-- hole 実行順に逐次読みだして実行していく --> ことを オ: <!-- hole 逐次処理方式 --> という。  
プログラムと同じ場所にカ: <!-- hole データが格納 --> されていて、  
キ: <!-- hole 高速だが小容量のメモリ「レジスタ」 --> があり、  
ク: <!-- hole キャッシュメモリやメインメモリ --> もあり、  
キと他のメモリ間のデータ転送をプログラムで指示するものを  
ケ: <!-- hole 単一メモリ方式 --> あるいはコ: <!-- hole ロードストアアーキテクチャ --> という。  

### レジスタ
＄0から＄ア: <!-- hole 31 --> のア+1個。  
レジスタ長はすべてイ: <!-- hole 32 --> bit  

＄0はウ: <!-- hole 何を書き込もうとしても書き込めず、定数0となる --> 定数レジスタである。  
必要のなくなったデータの書き込み先などとして有用。  

＄1から＄アはエ: <!-- 汎用レジスタ --> といい、自由に値を書き込める。


### 命令

命令はア: <!-- hole オプコード --> とイ: <!-- hole オペランド -->  で構成される。  
アは実行する命令の種類を明示し、イは操作の対象である。  
命令フォーマットは、一般的にウ: <!-- hole オプコード|オペランド1|オペランド2|... --> のようになっている。  

#### 算術演算命令

足し算は「ア: <!-- hole add --> イ: <!-- hole ＄1,＄2,＄3 -->」 と命令する。  

この命令の意味は、ウ: <!-- hole ＄2と＄3を足し算し、＄1へ格納せよ --> である。  

引き算の場合は「エ: <!-- hole sub --> イ」  
となる。  

＄1のことをオ: <!-- hole ディスティネーションオペランド --> といい、  
＄2、＄3のことをカ: <!-- hole 第1あるいは第2ソースオペランド --> という。  

オペランドはオ: <!-- hole レジスタのみ --> であることに注意  

#### データ転送命令

「ア: <!-- hole lw --> ＄1,100(＄2)」  
はイ: <!-- hole ＄2の値に10進数100を加算した番地 --> からウ: <!-- hole 4バイト のデータを読み出し、  
＄1へ格納する -->   
「ウ: <!-- hole sw --> ＄1,100(＄2)」  
はイにエ: <!-- hole ＄1の値を格納する -->  

100の部分をオ: <!-- hole ディスプレースメント --> といったりする。  

オペランドは(メモリ、レジスタ)の組のみ。

#### 機械語命令フォーマット(R形式)

ア: <!-- hole op(6bit)|rs(5bit)|rt(5bit)|rd(5bit)|shamt(5bit)|funct(6bit) -->  
である。  
opは命令操作(定数0)、  
rsはイ: <!-- hole 第1ソースオペランドのレジスタ番号 -->  
rtはウ: <!-- hole 第2ソースオペランドのレジスタ番号 -->  
rdはエ: <!-- hole ディスティネーションオペランドのレジスタ番号 -->  
shamtはオ: <!-- hole shift_amountつまりシフト量 -->  
functはカ: <!-- hole 機能 -->  
  
追記:キ～シは取り組む必要なし  

functがキ: <!-- hole 100000 --> ならオプコードはadd  
ク: <!-- hole 100010 --> ならsub  
ケ: <!-- hole 100100 --> ならand  
コ: <!-- hole 100101 --> ならor  
サ: <!-- hole 101010 --> ならslt  
シ: <!-- hole 001000 --> ならjr  
となる。  
sltは、ス: <!-- hole 第1ソースオペランドより第2ソースオペランドのほうが大きいとき --> 、ディスティネーションオペランドを1、そうでないとき0とする。  
jrは、セ: <!-- hole ディスティネーションオペランドに指定されたレジスタの保持するアドレスへ分岐 --> するという動作をする。  


#### 機械語命令フォーマット(I形式)

ア: <!-- hole op(6bit)|rs(5bit)|address(16bit) -->  
である。  
opは命令操作、  
rsはイ: <!-- hole ソースオペランドのレジスタ番号 -->  
rtはウ: <!-- hole ディスティネーションオペランドのレジスタ番号 -->  
addressはエ: <!-- hole ディスプレースメント値(符号付き16bit2進整数) -->
  
追記:カ～コは取り組む必要なし  
  
opがオ: <!-- hole 100011 --> ならオプコードはlw  
カ: <!-- hole 101011 --> ならsw  
キ: <!-- hole 000100 --> ならbeq(条件分岐(1のとき))  
ク: <!-- hole 000101 --> ならbne(条件分岐(0のとき))  
ケ: <!-- hole 001000 --> ならaddi(定数加算)  
コ: <!-- hole 001010 --> ならslti(定数比較)  

beq,bneは条件分岐である。この場合、addressはエでなく、  
サ: <!-- hole 次の命令から飛び先命令までの命令数 --> となる。  

beq ＄1,＄2,L1  

L1: add ＄5,＄6,＄7  

のとき、コは0で、  

L1: beq ＄1,＄2,L1  

のときはコは-1  

addiは 「addi シ: <!-- hole ＄1,＄2,定数(16bit) --> 」のように使う。  
意味は、ス: <!-- hole ＄2に定数を加えたものを＄1に格納せよ --> である。  

sltiは 「slti シ」のように使う。  
意味は、セ: <!-- hole 定数が＄2より大きければ＄1に1を、そうでなければ0を格納せよ --> である。  




#### 機械語命令フォーマット(J形式)

ア: <!-- hole op(6bit)|address(26bit) -->  
である。  
opがイ: <!-- hole 000010 --> ならj(無条件分岐)  
ウ: <!-- hole 000011 --> ならjal(サブルーチン呼び出し)  

j(無条件分岐)の場合、32bitのアドレスに飛ぶわけである。  
まず、エ: <!-- hole address(26bit)の末尾に00をつけ --> て28bitにする。  
次に、オ: <!-- hole PCの上位4bitを先頭に付け --> て32bitにして、このアドレスに飛ぶ。  

jal(サブルーチン呼び出し)は、カ: <!-- hole 分岐先アドレスに無条件ジャンプするが、その際に戻り番地を＄31に保存 --> するという動作をする。  
つまり、jalが動作してからは、キ: <!-- 分岐先(サブルーチン)で＄31を変更 --> しない限り、＄31にはク: <!-- hole jalの直を意味するアドレス --> が入る。  

注意:jrはJ形式ではなく、ク: <!-- hole R --> 形式である。  
これはおそらく、ケ: <!-- hole オペランドがレジスタとなる --> からではなかろうかと思う。  

### オペランドの数によるアーキテクチャの分類

#### オペランド0個

命令にア: <!-- hole 明示的 --> なオペランドがない。  
これがみられるのは、イ: <!-- スタック -->  
である。  

メモリ内の変数Xに7を加える例を考えよう。  

push X  
push 7  
add  
pop X  

確かにadd自体にはオペランドが(0個しか)ない。  

ハードウェア イ というものがある。チップ内に独立実装される。  
ウ: <!-- hole 主記憶装置 --> 上に実現。  
どこにプッシュし、どこからポップするのかはエ: <!-- hole スタックポインタ --> が記憶する。  
これは、オ: <!-- hole プロセッサ内の専用レジスタ --> が担う。  


#### オペランド1個  

ア: <!-- hole 電卓の操作 --> をイメージすればよい。  

イ: <!-- hole アキュムレータ --> を使用する。(重要)  

イとは、アでいうと、ウ: <!-- hole 現在の結果を保持しているもの --> のことである。  
唯一のオペランドは、演算命令のエ: <!-- hole 二つ目 --> の引数である。  
  
メモリ内の変数Xに7を加える例を考えよう。  

load X  
add 7  
store X  

確かに、addのオペランドは1つである。  

#### オペランド2個

ア: <!-- hole 命令ごとに明示的に --> 2つのオペランド  

結果はイ: <!-- hole デスティネーションオペランド --> へウ: <!-- hole 上書き --> 。  

メモリ内の変数Xに7を加える例を考えよう。   

add 7,X  
と書けばよいとき、
add X,7 エ: <!-- hole と書いたらダメ(c言語でいう左辺地と右辺値を考えよ) -->  

#### オペランド3個

命令ごとに明示的に3つのオペランド  

結果はデスティネーションオペランドへ上書き。  

メモリ内の変数Xに7を加える例を考えよう。  

add X,7,X  

最初のオペランドがデスティネーションオペランドの場合、 ア: <!-- hole add X,X,7 --> に同じ。  

### オペランドの種類  

ソースオペランドでは、定数だったりレジスタの中身だったりメモリの中身だったりする。  
定数はア: <!-- hole 即値(immediate値) --> といったりして、イ: <!-- hole 命令内に直接埋め込まれる --> 。  

デスティネーションオペランドは、  
レジスタだったり、ア: <!-- hole メモリ位置 --> だったり、ったにないがイ: <!-- hole レジスタを組み合わせたもの --> である。  

### 命令の効率的な実行 

メモリにある変数XとYの値を加え、メモリ上の変数Zに格納する例を考えよう。  

X～ZのアドレスをAdrX～AdrZとしよう。  
角カッコでメモリの中身を表すことにしよう。  
［AdrX］は、ア: <!-- hole 変数Xの値 --> となる。  

Reg1～Reg3を3つのレジスタとしよう。  

メモリの値を加算する命令は、  
直接メモリの値を加算する場合、イ: <!-- hole add ［AdrZ］,［AdrX］,［AdrY］ --> であるが、ウ: <!-- hole メモリは動作が遅いため、すごく時間がかかる。 --> 
  
全てレジスタに読み込んでから加算する命令の場合、  

load Reg1,［AdRX］  
load Reg2,［AdrY］  
load Reg3,［AdrZ］  
add Reg3 Reg1, Reg2  
エ: <!-- hole store Reg3,［AdrZ］ --> 
となる。  

この場合、オ: <!-- hole 時間はかからない --> 。  
こういう風に、オペランドにできるだけレジスタを使用することで <!-- hole フォンノイマンボトルネック --> が回避される。  

### オペランドのトレードオフ 




























  
